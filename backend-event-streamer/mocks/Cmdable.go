// Code generated by mockery v2.50.4. DO NOT EDIT.

package mocks

import (
	context "context"

	redis "github.com/go-redis/redis/v8"
	mock "github.com/stretchr/testify/mock"

	time "time"
)

// Cmdable is an autogenerated mock type for the Cmdable type
type Cmdable struct {
	mock.Mock
}

// Append provides a mock function with given fields: ctx, key, value
func (_m *Cmdable) Append(ctx context.Context, key string, value string) *redis.IntCmd {
	ret := _m.Called(ctx, key, value)

	if len(ret) == 0 {
		panic("no return value specified for Append")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// BLMove provides a mock function with given fields: ctx, source, destination, srcpos, destpos, timeout
func (_m *Cmdable) BLMove(ctx context.Context, source string, destination string, srcpos string, destpos string, timeout time.Duration) *redis.StringCmd {
	ret := _m.Called(ctx, source, destination, srcpos, destpos, timeout)

	if len(ret) == 0 {
		panic("no return value specified for BLMove")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, time.Duration) *redis.StringCmd); ok {
		r0 = rf(ctx, source, destination, srcpos, destpos, timeout)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// BLPop provides a mock function with given fields: ctx, timeout, keys
func (_m *Cmdable) BLPop(ctx context.Context, timeout time.Duration, keys ...string) *redis.StringSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, timeout)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BLPop")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, time.Duration, ...string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, timeout, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// BRPop provides a mock function with given fields: ctx, timeout, keys
func (_m *Cmdable) BRPop(ctx context.Context, timeout time.Duration, keys ...string) *redis.StringSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, timeout)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BRPop")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, time.Duration, ...string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, timeout, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// BRPopLPush provides a mock function with given fields: ctx, source, destination, timeout
func (_m *Cmdable) BRPopLPush(ctx context.Context, source string, destination string, timeout time.Duration) *redis.StringCmd {
	ret := _m.Called(ctx, source, destination, timeout)

	if len(ret) == 0 {
		panic("no return value specified for BRPopLPush")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, time.Duration) *redis.StringCmd); ok {
		r0 = rf(ctx, source, destination, timeout)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// BZPopMax provides a mock function with given fields: ctx, timeout, keys
func (_m *Cmdable) BZPopMax(ctx context.Context, timeout time.Duration, keys ...string) *redis.ZWithKeyCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, timeout)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BZPopMax")
	}

	var r0 *redis.ZWithKeyCmd
	if rf, ok := ret.Get(0).(func(context.Context, time.Duration, ...string) *redis.ZWithKeyCmd); ok {
		r0 = rf(ctx, timeout, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZWithKeyCmd)
		}
	}

	return r0
}

// BZPopMin provides a mock function with given fields: ctx, timeout, keys
func (_m *Cmdable) BZPopMin(ctx context.Context, timeout time.Duration, keys ...string) *redis.ZWithKeyCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, timeout)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BZPopMin")
	}

	var r0 *redis.ZWithKeyCmd
	if rf, ok := ret.Get(0).(func(context.Context, time.Duration, ...string) *redis.ZWithKeyCmd); ok {
		r0 = rf(ctx, timeout, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZWithKeyCmd)
		}
	}

	return r0
}

// BgRewriteAOF provides a mock function with given fields: ctx
func (_m *Cmdable) BgRewriteAOF(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for BgRewriteAOF")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// BgSave provides a mock function with given fields: ctx
func (_m *Cmdable) BgSave(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for BgSave")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// BitCount provides a mock function with given fields: ctx, key, bitCount
func (_m *Cmdable) BitCount(ctx context.Context, key string, bitCount *redis.BitCount) *redis.IntCmd {
	ret := _m.Called(ctx, key, bitCount)

	if len(ret) == 0 {
		panic("no return value specified for BitCount")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.BitCount) *redis.IntCmd); ok {
		r0 = rf(ctx, key, bitCount)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// BitField provides a mock function with given fields: ctx, key, args
func (_m *Cmdable) BitField(ctx context.Context, key string, args ...interface{}) *redis.IntSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BitField")
	}

	var r0 *redis.IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.IntSliceCmd); ok {
		r0 = rf(ctx, key, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntSliceCmd)
		}
	}

	return r0
}

// BitOpAnd provides a mock function with given fields: ctx, destKey, keys
func (_m *Cmdable) BitOpAnd(ctx context.Context, destKey string, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, destKey)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BitOpAnd")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, destKey, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// BitOpNot provides a mock function with given fields: ctx, destKey, key
func (_m *Cmdable) BitOpNot(ctx context.Context, destKey string, key string) *redis.IntCmd {
	ret := _m.Called(ctx, destKey, key)

	if len(ret) == 0 {
		panic("no return value specified for BitOpNot")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, destKey, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// BitOpOr provides a mock function with given fields: ctx, destKey, keys
func (_m *Cmdable) BitOpOr(ctx context.Context, destKey string, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, destKey)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BitOpOr")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, destKey, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// BitOpXor provides a mock function with given fields: ctx, destKey, keys
func (_m *Cmdable) BitOpXor(ctx context.Context, destKey string, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, destKey)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BitOpXor")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, destKey, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// BitPos provides a mock function with given fields: ctx, key, bit, pos
func (_m *Cmdable) BitPos(ctx context.Context, key string, bit int64, pos ...int64) *redis.IntCmd {
	_va := make([]interface{}, len(pos))
	for _i := range pos {
		_va[_i] = pos[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key, bit)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BitPos")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, ...int64) *redis.IntCmd); ok {
		r0 = rf(ctx, key, bit, pos...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ClientGetName provides a mock function with given fields: ctx
func (_m *Cmdable) ClientGetName(ctx context.Context) *redis.StringCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClientGetName")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StringCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// ClientID provides a mock function with given fields: ctx
func (_m *Cmdable) ClientID(ctx context.Context) *redis.IntCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClientID")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.IntCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ClientKill provides a mock function with given fields: ctx, ipPort
func (_m *Cmdable) ClientKill(ctx context.Context, ipPort string) *redis.StatusCmd {
	ret := _m.Called(ctx, ipPort)

	if len(ret) == 0 {
		panic("no return value specified for ClientKill")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, ipPort)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClientKillByFilter provides a mock function with given fields: ctx, keys
func (_m *Cmdable) ClientKillByFilter(ctx context.Context, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClientKillByFilter")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ClientList provides a mock function with given fields: ctx
func (_m *Cmdable) ClientList(ctx context.Context) *redis.StringCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClientList")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StringCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// ClientPause provides a mock function with given fields: ctx, dur
func (_m *Cmdable) ClientPause(ctx context.Context, dur time.Duration) *redis.BoolCmd {
	ret := _m.Called(ctx, dur)

	if len(ret) == 0 {
		panic("no return value specified for ClientPause")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, time.Duration) *redis.BoolCmd); ok {
		r0 = rf(ctx, dur)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// ClusterAddSlots provides a mock function with given fields: ctx, slots
func (_m *Cmdable) ClusterAddSlots(ctx context.Context, slots ...int) *redis.StatusCmd {
	_va := make([]interface{}, len(slots))
	for _i := range slots {
		_va[_i] = slots[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterAddSlots")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...int) *redis.StatusCmd); ok {
		r0 = rf(ctx, slots...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterAddSlotsRange provides a mock function with given fields: ctx, min, max
func (_m *Cmdable) ClusterAddSlotsRange(ctx context.Context, min int, max int) *redis.StatusCmd {
	ret := _m.Called(ctx, min, max)

	if len(ret) == 0 {
		panic("no return value specified for ClusterAddSlotsRange")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, int, int) *redis.StatusCmd); ok {
		r0 = rf(ctx, min, max)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterCountFailureReports provides a mock function with given fields: ctx, nodeID
func (_m *Cmdable) ClusterCountFailureReports(ctx context.Context, nodeID string) *redis.IntCmd {
	ret := _m.Called(ctx, nodeID)

	if len(ret) == 0 {
		panic("no return value specified for ClusterCountFailureReports")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.IntCmd); ok {
		r0 = rf(ctx, nodeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ClusterCountKeysInSlot provides a mock function with given fields: ctx, slot
func (_m *Cmdable) ClusterCountKeysInSlot(ctx context.Context, slot int) *redis.IntCmd {
	ret := _m.Called(ctx, slot)

	if len(ret) == 0 {
		panic("no return value specified for ClusterCountKeysInSlot")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, int) *redis.IntCmd); ok {
		r0 = rf(ctx, slot)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ClusterDelSlots provides a mock function with given fields: ctx, slots
func (_m *Cmdable) ClusterDelSlots(ctx context.Context, slots ...int) *redis.StatusCmd {
	_va := make([]interface{}, len(slots))
	for _i := range slots {
		_va[_i] = slots[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterDelSlots")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...int) *redis.StatusCmd); ok {
		r0 = rf(ctx, slots...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterDelSlotsRange provides a mock function with given fields: ctx, min, max
func (_m *Cmdable) ClusterDelSlotsRange(ctx context.Context, min int, max int) *redis.StatusCmd {
	ret := _m.Called(ctx, min, max)

	if len(ret) == 0 {
		panic("no return value specified for ClusterDelSlotsRange")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, int, int) *redis.StatusCmd); ok {
		r0 = rf(ctx, min, max)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterFailover provides a mock function with given fields: ctx
func (_m *Cmdable) ClusterFailover(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClusterFailover")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterForget provides a mock function with given fields: ctx, nodeID
func (_m *Cmdable) ClusterForget(ctx context.Context, nodeID string) *redis.StatusCmd {
	ret := _m.Called(ctx, nodeID)

	if len(ret) == 0 {
		panic("no return value specified for ClusterForget")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, nodeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterGetKeysInSlot provides a mock function with given fields: ctx, slot, count
func (_m *Cmdable) ClusterGetKeysInSlot(ctx context.Context, slot int, count int) *redis.StringSliceCmd {
	ret := _m.Called(ctx, slot, count)

	if len(ret) == 0 {
		panic("no return value specified for ClusterGetKeysInSlot")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, int, int) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, slot, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ClusterInfo provides a mock function with given fields: ctx
func (_m *Cmdable) ClusterInfo(ctx context.Context) *redis.StringCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClusterInfo")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StringCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// ClusterKeySlot provides a mock function with given fields: ctx, key
func (_m *Cmdable) ClusterKeySlot(ctx context.Context, key string) *redis.IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for ClusterKeySlot")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ClusterMeet provides a mock function with given fields: ctx, host, port
func (_m *Cmdable) ClusterMeet(ctx context.Context, host string, port string) *redis.StatusCmd {
	ret := _m.Called(ctx, host, port)

	if len(ret) == 0 {
		panic("no return value specified for ClusterMeet")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, host, port)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterNodes provides a mock function with given fields: ctx
func (_m *Cmdable) ClusterNodes(ctx context.Context) *redis.StringCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClusterNodes")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StringCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// ClusterReplicate provides a mock function with given fields: ctx, nodeID
func (_m *Cmdable) ClusterReplicate(ctx context.Context, nodeID string) *redis.StatusCmd {
	ret := _m.Called(ctx, nodeID)

	if len(ret) == 0 {
		panic("no return value specified for ClusterReplicate")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, nodeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterResetHard provides a mock function with given fields: ctx
func (_m *Cmdable) ClusterResetHard(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClusterResetHard")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterResetSoft provides a mock function with given fields: ctx
func (_m *Cmdable) ClusterResetSoft(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClusterResetSoft")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterSaveConfig provides a mock function with given fields: ctx
func (_m *Cmdable) ClusterSaveConfig(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClusterSaveConfig")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterSlaves provides a mock function with given fields: ctx, nodeID
func (_m *Cmdable) ClusterSlaves(ctx context.Context, nodeID string) *redis.StringSliceCmd {
	ret := _m.Called(ctx, nodeID)

	if len(ret) == 0 {
		panic("no return value specified for ClusterSlaves")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, nodeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ClusterSlots provides a mock function with given fields: ctx
func (_m *Cmdable) ClusterSlots(ctx context.Context) *redis.ClusterSlotsCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClusterSlots")
	}

	var r0 *redis.ClusterSlotsCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.ClusterSlotsCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ClusterSlotsCmd)
		}
	}

	return r0
}

// Command provides a mock function with given fields: ctx
func (_m *Cmdable) Command(ctx context.Context) *redis.CommandsInfoCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Command")
	}

	var r0 *redis.CommandsInfoCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.CommandsInfoCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.CommandsInfoCmd)
		}
	}

	return r0
}

// ConfigGet provides a mock function with given fields: ctx, parameter
func (_m *Cmdable) ConfigGet(ctx context.Context, parameter string) *redis.SliceCmd {
	ret := _m.Called(ctx, parameter)

	if len(ret) == 0 {
		panic("no return value specified for ConfigGet")
	}

	var r0 *redis.SliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.SliceCmd); ok {
		r0 = rf(ctx, parameter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.SliceCmd)
		}
	}

	return r0
}

// ConfigResetStat provides a mock function with given fields: ctx
func (_m *Cmdable) ConfigResetStat(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ConfigResetStat")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ConfigRewrite provides a mock function with given fields: ctx
func (_m *Cmdable) ConfigRewrite(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ConfigRewrite")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ConfigSet provides a mock function with given fields: ctx, parameter, value
func (_m *Cmdable) ConfigSet(ctx context.Context, parameter string, value string) *redis.StatusCmd {
	ret := _m.Called(ctx, parameter, value)

	if len(ret) == 0 {
		panic("no return value specified for ConfigSet")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, parameter, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// Copy provides a mock function with given fields: ctx, sourceKey, destKey, db, replace
func (_m *Cmdable) Copy(ctx context.Context, sourceKey string, destKey string, db int, replace bool) *redis.IntCmd {
	ret := _m.Called(ctx, sourceKey, destKey, db, replace)

	if len(ret) == 0 {
		panic("no return value specified for Copy")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int, bool) *redis.IntCmd); ok {
		r0 = rf(ctx, sourceKey, destKey, db, replace)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// DBSize provides a mock function with given fields: ctx
func (_m *Cmdable) DBSize(ctx context.Context) *redis.IntCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for DBSize")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.IntCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// DebugObject provides a mock function with given fields: ctx, key
func (_m *Cmdable) DebugObject(ctx context.Context, key string) *redis.StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for DebugObject")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// Decr provides a mock function with given fields: ctx, key
func (_m *Cmdable) Decr(ctx context.Context, key string) *redis.IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for Decr")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// DecrBy provides a mock function with given fields: ctx, key, decrement
func (_m *Cmdable) DecrBy(ctx context.Context, key string, decrement int64) *redis.IntCmd {
	ret := _m.Called(ctx, key, decrement)

	if len(ret) == 0 {
		panic("no return value specified for DecrBy")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *redis.IntCmd); ok {
		r0 = rf(ctx, key, decrement)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// Del provides a mock function with given fields: ctx, keys
func (_m *Cmdable) Del(ctx context.Context, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Del")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// Dump provides a mock function with given fields: ctx, key
func (_m *Cmdable) Dump(ctx context.Context, key string) *redis.StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for Dump")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// Echo provides a mock function with given fields: ctx, message
func (_m *Cmdable) Echo(ctx context.Context, message interface{}) *redis.StringCmd {
	ret := _m.Called(ctx, message)

	if len(ret) == 0 {
		panic("no return value specified for Echo")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, interface{}) *redis.StringCmd); ok {
		r0 = rf(ctx, message)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// Eval provides a mock function with given fields: ctx, script, keys, args
func (_m *Cmdable) Eval(ctx context.Context, script string, keys []string, args ...interface{}) *redis.Cmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, script, keys)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Eval")
	}

	var r0 *redis.Cmd
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, ...interface{}) *redis.Cmd); ok {
		r0 = rf(ctx, script, keys, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.Cmd)
		}
	}

	return r0
}

// EvalSha provides a mock function with given fields: ctx, sha1, keys, args
func (_m *Cmdable) EvalSha(ctx context.Context, sha1 string, keys []string, args ...interface{}) *redis.Cmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, sha1, keys)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EvalSha")
	}

	var r0 *redis.Cmd
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, ...interface{}) *redis.Cmd); ok {
		r0 = rf(ctx, sha1, keys, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.Cmd)
		}
	}

	return r0
}

// Exists provides a mock function with given fields: ctx, keys
func (_m *Cmdable) Exists(ctx context.Context, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// Expire provides a mock function with given fields: ctx, key, expiration
func (_m *Cmdable) Expire(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
	ret := _m.Called(ctx, key, expiration)

	if len(ret) == 0 {
		panic("no return value specified for Expire")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// ExpireAt provides a mock function with given fields: ctx, key, tm
func (_m *Cmdable) ExpireAt(ctx context.Context, key string, tm time.Time) *redis.BoolCmd {
	ret := _m.Called(ctx, key, tm)

	if len(ret) == 0 {
		panic("no return value specified for ExpireAt")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Time) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, tm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// ExpireGT provides a mock function with given fields: ctx, key, expiration
func (_m *Cmdable) ExpireGT(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
	ret := _m.Called(ctx, key, expiration)

	if len(ret) == 0 {
		panic("no return value specified for ExpireGT")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// ExpireLT provides a mock function with given fields: ctx, key, expiration
func (_m *Cmdable) ExpireLT(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
	ret := _m.Called(ctx, key, expiration)

	if len(ret) == 0 {
		panic("no return value specified for ExpireLT")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// ExpireNX provides a mock function with given fields: ctx, key, expiration
func (_m *Cmdable) ExpireNX(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
	ret := _m.Called(ctx, key, expiration)

	if len(ret) == 0 {
		panic("no return value specified for ExpireNX")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// ExpireXX provides a mock function with given fields: ctx, key, expiration
func (_m *Cmdable) ExpireXX(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
	ret := _m.Called(ctx, key, expiration)

	if len(ret) == 0 {
		panic("no return value specified for ExpireXX")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// FlushAll provides a mock function with given fields: ctx
func (_m *Cmdable) FlushAll(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for FlushAll")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// FlushAllAsync provides a mock function with given fields: ctx
func (_m *Cmdable) FlushAllAsync(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for FlushAllAsync")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// FlushDB provides a mock function with given fields: ctx
func (_m *Cmdable) FlushDB(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for FlushDB")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// FlushDBAsync provides a mock function with given fields: ctx
func (_m *Cmdable) FlushDBAsync(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for FlushDBAsync")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// GeoAdd provides a mock function with given fields: ctx, key, geoLocation
func (_m *Cmdable) GeoAdd(ctx context.Context, key string, geoLocation ...*redis.GeoLocation) *redis.IntCmd {
	_va := make([]interface{}, len(geoLocation))
	for _i := range geoLocation {
		_va[_i] = geoLocation[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GeoAdd")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...*redis.GeoLocation) *redis.IntCmd); ok {
		r0 = rf(ctx, key, geoLocation...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// GeoDist provides a mock function with given fields: ctx, key, member1, member2, unit
func (_m *Cmdable) GeoDist(ctx context.Context, key string, member1 string, member2 string, unit string) *redis.FloatCmd {
	ret := _m.Called(ctx, key, member1, member2, unit)

	if len(ret) == 0 {
		panic("no return value specified for GeoDist")
	}

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) *redis.FloatCmd); ok {
		r0 = rf(ctx, key, member1, member2, unit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// GeoHash provides a mock function with given fields: ctx, key, members
func (_m *Cmdable) GeoHash(ctx context.Context, key string, members ...string) *redis.StringSliceCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GeoHash")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// GeoPos provides a mock function with given fields: ctx, key, members
func (_m *Cmdable) GeoPos(ctx context.Context, key string, members ...string) *redis.GeoPosCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GeoPos")
	}

	var r0 *redis.GeoPosCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.GeoPosCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.GeoPosCmd)
		}
	}

	return r0
}

// GeoRadius provides a mock function with given fields: ctx, key, longitude, latitude, query
func (_m *Cmdable) GeoRadius(ctx context.Context, key string, longitude float64, latitude float64, query *redis.GeoRadiusQuery) *redis.GeoLocationCmd {
	ret := _m.Called(ctx, key, longitude, latitude, query)

	if len(ret) == 0 {
		panic("no return value specified for GeoRadius")
	}

	var r0 *redis.GeoLocationCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, float64, float64, *redis.GeoRadiusQuery) *redis.GeoLocationCmd); ok {
		r0 = rf(ctx, key, longitude, latitude, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.GeoLocationCmd)
		}
	}

	return r0
}

// GeoRadiusByMember provides a mock function with given fields: ctx, key, member, query
func (_m *Cmdable) GeoRadiusByMember(ctx context.Context, key string, member string, query *redis.GeoRadiusQuery) *redis.GeoLocationCmd {
	ret := _m.Called(ctx, key, member, query)

	if len(ret) == 0 {
		panic("no return value specified for GeoRadiusByMember")
	}

	var r0 *redis.GeoLocationCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *redis.GeoRadiusQuery) *redis.GeoLocationCmd); ok {
		r0 = rf(ctx, key, member, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.GeoLocationCmd)
		}
	}

	return r0
}

// GeoRadiusByMemberStore provides a mock function with given fields: ctx, key, member, query
func (_m *Cmdable) GeoRadiusByMemberStore(ctx context.Context, key string, member string, query *redis.GeoRadiusQuery) *redis.IntCmd {
	ret := _m.Called(ctx, key, member, query)

	if len(ret) == 0 {
		panic("no return value specified for GeoRadiusByMemberStore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *redis.GeoRadiusQuery) *redis.IntCmd); ok {
		r0 = rf(ctx, key, member, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// GeoRadiusStore provides a mock function with given fields: ctx, key, longitude, latitude, query
func (_m *Cmdable) GeoRadiusStore(ctx context.Context, key string, longitude float64, latitude float64, query *redis.GeoRadiusQuery) *redis.IntCmd {
	ret := _m.Called(ctx, key, longitude, latitude, query)

	if len(ret) == 0 {
		panic("no return value specified for GeoRadiusStore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, float64, float64, *redis.GeoRadiusQuery) *redis.IntCmd); ok {
		r0 = rf(ctx, key, longitude, latitude, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// GeoSearch provides a mock function with given fields: ctx, key, q
func (_m *Cmdable) GeoSearch(ctx context.Context, key string, q *redis.GeoSearchQuery) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, q)

	if len(ret) == 0 {
		panic("no return value specified for GeoSearch")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.GeoSearchQuery) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, q)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// GeoSearchLocation provides a mock function with given fields: ctx, key, q
func (_m *Cmdable) GeoSearchLocation(ctx context.Context, key string, q *redis.GeoSearchLocationQuery) *redis.GeoSearchLocationCmd {
	ret := _m.Called(ctx, key, q)

	if len(ret) == 0 {
		panic("no return value specified for GeoSearchLocation")
	}

	var r0 *redis.GeoSearchLocationCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.GeoSearchLocationQuery) *redis.GeoSearchLocationCmd); ok {
		r0 = rf(ctx, key, q)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.GeoSearchLocationCmd)
		}
	}

	return r0
}

// GeoSearchStore provides a mock function with given fields: ctx, key, store, q
func (_m *Cmdable) GeoSearchStore(ctx context.Context, key string, store string, q *redis.GeoSearchStoreQuery) *redis.IntCmd {
	ret := _m.Called(ctx, key, store, q)

	if len(ret) == 0 {
		panic("no return value specified for GeoSearchStore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *redis.GeoSearchStoreQuery) *redis.IntCmd); ok {
		r0 = rf(ctx, key, store, q)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// Get provides a mock function with given fields: ctx, key
func (_m *Cmdable) Get(ctx context.Context, key string) *redis.StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// GetBit provides a mock function with given fields: ctx, key, offset
func (_m *Cmdable) GetBit(ctx context.Context, key string, offset int64) *redis.IntCmd {
	ret := _m.Called(ctx, key, offset)

	if len(ret) == 0 {
		panic("no return value specified for GetBit")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *redis.IntCmd); ok {
		r0 = rf(ctx, key, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// GetDel provides a mock function with given fields: ctx, key
func (_m *Cmdable) GetDel(ctx context.Context, key string) *redis.StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for GetDel")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// GetEx provides a mock function with given fields: ctx, key, expiration
func (_m *Cmdable) GetEx(ctx context.Context, key string, expiration time.Duration) *redis.StringCmd {
	ret := _m.Called(ctx, key, expiration)

	if len(ret) == 0 {
		panic("no return value specified for GetEx")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) *redis.StringCmd); ok {
		r0 = rf(ctx, key, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// GetRange provides a mock function with given fields: ctx, key, start, end
func (_m *Cmdable) GetRange(ctx context.Context, key string, start int64, end int64) *redis.StringCmd {
	ret := _m.Called(ctx, key, start, end)

	if len(ret) == 0 {
		panic("no return value specified for GetRange")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *redis.StringCmd); ok {
		r0 = rf(ctx, key, start, end)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// GetSet provides a mock function with given fields: ctx, key, value
func (_m *Cmdable) GetSet(ctx context.Context, key string, value interface{}) *redis.StringCmd {
	ret := _m.Called(ctx, key, value)

	if len(ret) == 0 {
		panic("no return value specified for GetSet")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) *redis.StringCmd); ok {
		r0 = rf(ctx, key, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// HDel provides a mock function with given fields: ctx, key, fields
func (_m *Cmdable) HDel(ctx context.Context, key string, fields ...string) *redis.IntCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HDel")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, key, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// HExists provides a mock function with given fields: ctx, key, field
func (_m *Cmdable) HExists(ctx context.Context, key string, field string) *redis.BoolCmd {
	ret := _m.Called(ctx, key, field)

	if len(ret) == 0 {
		panic("no return value specified for HExists")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, field)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// HGet provides a mock function with given fields: ctx, key, field
func (_m *Cmdable) HGet(ctx context.Context, key string, field string) *redis.StringCmd {
	ret := _m.Called(ctx, key, field)

	if len(ret) == 0 {
		panic("no return value specified for HGet")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.StringCmd); ok {
		r0 = rf(ctx, key, field)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// HGetAll provides a mock function with given fields: ctx, key
func (_m *Cmdable) HGetAll(ctx context.Context, key string) *redis.StringStringMapCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for HGetAll")
	}

	var r0 *redis.StringStringMapCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringStringMapCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringStringMapCmd)
		}
	}

	return r0
}

// HIncrBy provides a mock function with given fields: ctx, key, field, incr
func (_m *Cmdable) HIncrBy(ctx context.Context, key string, field string, incr int64) *redis.IntCmd {
	ret := _m.Called(ctx, key, field, incr)

	if len(ret) == 0 {
		panic("no return value specified for HIncrBy")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int64) *redis.IntCmd); ok {
		r0 = rf(ctx, key, field, incr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// HIncrByFloat provides a mock function with given fields: ctx, key, field, incr
func (_m *Cmdable) HIncrByFloat(ctx context.Context, key string, field string, incr float64) *redis.FloatCmd {
	ret := _m.Called(ctx, key, field, incr)

	if len(ret) == 0 {
		panic("no return value specified for HIncrByFloat")
	}

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, float64) *redis.FloatCmd); ok {
		r0 = rf(ctx, key, field, incr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// HKeys provides a mock function with given fields: ctx, key
func (_m *Cmdable) HKeys(ctx context.Context, key string) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for HKeys")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// HLen provides a mock function with given fields: ctx, key
func (_m *Cmdable) HLen(ctx context.Context, key string) *redis.IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for HLen")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// HMGet provides a mock function with given fields: ctx, key, fields
func (_m *Cmdable) HMGet(ctx context.Context, key string, fields ...string) *redis.SliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HMGet")
	}

	var r0 *redis.SliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.SliceCmd); ok {
		r0 = rf(ctx, key, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.SliceCmd)
		}
	}

	return r0
}

// HMSet provides a mock function with given fields: ctx, key, values
func (_m *Cmdable) HMSet(ctx context.Context, key string, values ...interface{}) *redis.BoolCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HMSet")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// HRandField provides a mock function with given fields: ctx, key, count, withValues
func (_m *Cmdable) HRandField(ctx context.Context, key string, count int, withValues bool) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, count, withValues)

	if len(ret) == 0 {
		panic("no return value specified for HRandField")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int, bool) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, count, withValues)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// HScan provides a mock function with given fields: ctx, key, cursor, match, count
func (_m *Cmdable) HScan(ctx context.Context, key string, cursor uint64, match string, count int64) *redis.ScanCmd {
	ret := _m.Called(ctx, key, cursor, match, count)

	if len(ret) == 0 {
		panic("no return value specified for HScan")
	}

	var r0 *redis.ScanCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, uint64, string, int64) *redis.ScanCmd); ok {
		r0 = rf(ctx, key, cursor, match, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ScanCmd)
		}
	}

	return r0
}

// HSet provides a mock function with given fields: ctx, key, values
func (_m *Cmdable) HSet(ctx context.Context, key string, values ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HSet")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// HSetNX provides a mock function with given fields: ctx, key, field, value
func (_m *Cmdable) HSetNX(ctx context.Context, key string, field string, value interface{}) *redis.BoolCmd {
	ret := _m.Called(ctx, key, field, value)

	if len(ret) == 0 {
		panic("no return value specified for HSetNX")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, interface{}) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, field, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// HVals provides a mock function with given fields: ctx, key
func (_m *Cmdable) HVals(ctx context.Context, key string) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for HVals")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// Incr provides a mock function with given fields: ctx, key
func (_m *Cmdable) Incr(ctx context.Context, key string) *redis.IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for Incr")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// IncrBy provides a mock function with given fields: ctx, key, value
func (_m *Cmdable) IncrBy(ctx context.Context, key string, value int64) *redis.IntCmd {
	ret := _m.Called(ctx, key, value)

	if len(ret) == 0 {
		panic("no return value specified for IncrBy")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *redis.IntCmd); ok {
		r0 = rf(ctx, key, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// IncrByFloat provides a mock function with given fields: ctx, key, value
func (_m *Cmdable) IncrByFloat(ctx context.Context, key string, value float64) *redis.FloatCmd {
	ret := _m.Called(ctx, key, value)

	if len(ret) == 0 {
		panic("no return value specified for IncrByFloat")
	}

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, float64) *redis.FloatCmd); ok {
		r0 = rf(ctx, key, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// Info provides a mock function with given fields: ctx, section
func (_m *Cmdable) Info(ctx context.Context, section ...string) *redis.StringCmd {
	_va := make([]interface{}, len(section))
	for _i := range section {
		_va[_i] = section[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Info")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.StringCmd); ok {
		r0 = rf(ctx, section...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// Keys provides a mock function with given fields: ctx, pattern
func (_m *Cmdable) Keys(ctx context.Context, pattern string) *redis.StringSliceCmd {
	ret := _m.Called(ctx, pattern)

	if len(ret) == 0 {
		panic("no return value specified for Keys")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, pattern)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// LIndex provides a mock function with given fields: ctx, key, index
func (_m *Cmdable) LIndex(ctx context.Context, key string, index int64) *redis.StringCmd {
	ret := _m.Called(ctx, key, index)

	if len(ret) == 0 {
		panic("no return value specified for LIndex")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *redis.StringCmd); ok {
		r0 = rf(ctx, key, index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// LInsert provides a mock function with given fields: ctx, key, op, pivot, value
func (_m *Cmdable) LInsert(ctx context.Context, key string, op string, pivot interface{}, value interface{}) *redis.IntCmd {
	ret := _m.Called(ctx, key, op, pivot, value)

	if len(ret) == 0 {
		panic("no return value specified for LInsert")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, interface{}, interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, key, op, pivot, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// LInsertAfter provides a mock function with given fields: ctx, key, pivot, value
func (_m *Cmdable) LInsertAfter(ctx context.Context, key string, pivot interface{}, value interface{}) *redis.IntCmd {
	ret := _m.Called(ctx, key, pivot, value)

	if len(ret) == 0 {
		panic("no return value specified for LInsertAfter")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, key, pivot, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// LInsertBefore provides a mock function with given fields: ctx, key, pivot, value
func (_m *Cmdable) LInsertBefore(ctx context.Context, key string, pivot interface{}, value interface{}) *redis.IntCmd {
	ret := _m.Called(ctx, key, pivot, value)

	if len(ret) == 0 {
		panic("no return value specified for LInsertBefore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, key, pivot, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// LLen provides a mock function with given fields: ctx, key
func (_m *Cmdable) LLen(ctx context.Context, key string) *redis.IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for LLen")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// LMove provides a mock function with given fields: ctx, source, destination, srcpos, destpos
func (_m *Cmdable) LMove(ctx context.Context, source string, destination string, srcpos string, destpos string) *redis.StringCmd {
	ret := _m.Called(ctx, source, destination, srcpos, destpos)

	if len(ret) == 0 {
		panic("no return value specified for LMove")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) *redis.StringCmd); ok {
		r0 = rf(ctx, source, destination, srcpos, destpos)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// LPop provides a mock function with given fields: ctx, key
func (_m *Cmdable) LPop(ctx context.Context, key string) *redis.StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for LPop")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// LPopCount provides a mock function with given fields: ctx, key, count
func (_m *Cmdable) LPopCount(ctx context.Context, key string, count int) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, count)

	if len(ret) == 0 {
		panic("no return value specified for LPopCount")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// LPos provides a mock function with given fields: ctx, key, value, args
func (_m *Cmdable) LPos(ctx context.Context, key string, value string, args redis.LPosArgs) *redis.IntCmd {
	ret := _m.Called(ctx, key, value, args)

	if len(ret) == 0 {
		panic("no return value specified for LPos")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, redis.LPosArgs) *redis.IntCmd); ok {
		r0 = rf(ctx, key, value, args)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// LPosCount provides a mock function with given fields: ctx, key, value, count, args
func (_m *Cmdable) LPosCount(ctx context.Context, key string, value string, count int64, args redis.LPosArgs) *redis.IntSliceCmd {
	ret := _m.Called(ctx, key, value, count, args)

	if len(ret) == 0 {
		panic("no return value specified for LPosCount")
	}

	var r0 *redis.IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int64, redis.LPosArgs) *redis.IntSliceCmd); ok {
		r0 = rf(ctx, key, value, count, args)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntSliceCmd)
		}
	}

	return r0
}

// LPush provides a mock function with given fields: ctx, key, values
func (_m *Cmdable) LPush(ctx context.Context, key string, values ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LPush")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// LPushX provides a mock function with given fields: ctx, key, values
func (_m *Cmdable) LPushX(ctx context.Context, key string, values ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LPushX")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// LRange provides a mock function with given fields: ctx, key, start, stop
func (_m *Cmdable) LRange(ctx context.Context, key string, start int64, stop int64) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for LRange")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// LRem provides a mock function with given fields: ctx, key, count, value
func (_m *Cmdable) LRem(ctx context.Context, key string, count int64, value interface{}) *redis.IntCmd {
	ret := _m.Called(ctx, key, count, value)

	if len(ret) == 0 {
		panic("no return value specified for LRem")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, key, count, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// LSet provides a mock function with given fields: ctx, key, index, value
func (_m *Cmdable) LSet(ctx context.Context, key string, index int64, value interface{}) *redis.StatusCmd {
	ret := _m.Called(ctx, key, index, value)

	if len(ret) == 0 {
		panic("no return value specified for LSet")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, interface{}) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, index, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// LTrim provides a mock function with given fields: ctx, key, start, stop
func (_m *Cmdable) LTrim(ctx context.Context, key string, start int64, stop int64) *redis.StatusCmd {
	ret := _m.Called(ctx, key, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for LTrim")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// LastSave provides a mock function with given fields: ctx
func (_m *Cmdable) LastSave(ctx context.Context) *redis.IntCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for LastSave")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.IntCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MGet provides a mock function with given fields: ctx, keys
func (_m *Cmdable) MGet(ctx context.Context, keys ...string) *redis.SliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MGet")
	}

	var r0 *redis.SliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.SliceCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.SliceCmd)
		}
	}

	return r0
}

// MSet provides a mock function with given fields: ctx, values
func (_m *Cmdable) MSet(ctx context.Context, values ...interface{}) *redis.StatusCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MSet")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...interface{}) *redis.StatusCmd); ok {
		r0 = rf(ctx, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MSetNX provides a mock function with given fields: ctx, values
func (_m *Cmdable) MSetNX(ctx context.Context, values ...interface{}) *redis.BoolCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MSetNX")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...interface{}) *redis.BoolCmd); ok {
		r0 = rf(ctx, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// MemoryUsage provides a mock function with given fields: ctx, key, samples
func (_m *Cmdable) MemoryUsage(ctx context.Context, key string, samples ...int) *redis.IntCmd {
	_va := make([]interface{}, len(samples))
	for _i := range samples {
		_va[_i] = samples[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MemoryUsage")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...int) *redis.IntCmd); ok {
		r0 = rf(ctx, key, samples...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// Migrate provides a mock function with given fields: ctx, host, port, key, db, timeout
func (_m *Cmdable) Migrate(ctx context.Context, host string, port string, key string, db int, timeout time.Duration) *redis.StatusCmd {
	ret := _m.Called(ctx, host, port, key, db, timeout)

	if len(ret) == 0 {
		panic("no return value specified for Migrate")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int, time.Duration) *redis.StatusCmd); ok {
		r0 = rf(ctx, host, port, key, db, timeout)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// Move provides a mock function with given fields: ctx, key, db
func (_m *Cmdable) Move(ctx context.Context, key string, db int) *redis.BoolCmd {
	ret := _m.Called(ctx, key, db)

	if len(ret) == 0 {
		panic("no return value specified for Move")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, db)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// ObjectEncoding provides a mock function with given fields: ctx, key
func (_m *Cmdable) ObjectEncoding(ctx context.Context, key string) *redis.StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for ObjectEncoding")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// ObjectIdleTime provides a mock function with given fields: ctx, key
func (_m *Cmdable) ObjectIdleTime(ctx context.Context, key string) *redis.DurationCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for ObjectIdleTime")
	}

	var r0 *redis.DurationCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.DurationCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.DurationCmd)
		}
	}

	return r0
}

// ObjectRefCount provides a mock function with given fields: ctx, key
func (_m *Cmdable) ObjectRefCount(ctx context.Context, key string) *redis.IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for ObjectRefCount")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// PExpire provides a mock function with given fields: ctx, key, expiration
func (_m *Cmdable) PExpire(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
	ret := _m.Called(ctx, key, expiration)

	if len(ret) == 0 {
		panic("no return value specified for PExpire")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// PExpireAt provides a mock function with given fields: ctx, key, tm
func (_m *Cmdable) PExpireAt(ctx context.Context, key string, tm time.Time) *redis.BoolCmd {
	ret := _m.Called(ctx, key, tm)

	if len(ret) == 0 {
		panic("no return value specified for PExpireAt")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Time) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, tm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// PFAdd provides a mock function with given fields: ctx, key, els
func (_m *Cmdable) PFAdd(ctx context.Context, key string, els ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, els...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PFAdd")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, key, els...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// PFCount provides a mock function with given fields: ctx, keys
func (_m *Cmdable) PFCount(ctx context.Context, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PFCount")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// PFMerge provides a mock function with given fields: ctx, dest, keys
func (_m *Cmdable) PFMerge(ctx context.Context, dest string, keys ...string) *redis.StatusCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, dest)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PFMerge")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.StatusCmd); ok {
		r0 = rf(ctx, dest, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// PTTL provides a mock function with given fields: ctx, key
func (_m *Cmdable) PTTL(ctx context.Context, key string) *redis.DurationCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for PTTL")
	}

	var r0 *redis.DurationCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.DurationCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.DurationCmd)
		}
	}

	return r0
}

// Persist provides a mock function with given fields: ctx, key
func (_m *Cmdable) Persist(ctx context.Context, key string) *redis.BoolCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for Persist")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.BoolCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// Ping provides a mock function with given fields: ctx
func (_m *Cmdable) Ping(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Ping")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// Pipeline provides a mock function with no fields
func (_m *Cmdable) Pipeline() redis.Pipeliner {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Pipeline")
	}

	var r0 redis.Pipeliner
	if rf, ok := ret.Get(0).(func() redis.Pipeliner); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(redis.Pipeliner)
		}
	}

	return r0
}

// Pipelined provides a mock function with given fields: ctx, fn
func (_m *Cmdable) Pipelined(ctx context.Context, fn func(redis.Pipeliner) error) ([]redis.Cmder, error) {
	ret := _m.Called(ctx, fn)

	if len(ret) == 0 {
		panic("no return value specified for Pipelined")
	}

	var r0 []redis.Cmder
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, func(redis.Pipeliner) error) ([]redis.Cmder, error)); ok {
		return rf(ctx, fn)
	}
	if rf, ok := ret.Get(0).(func(context.Context, func(redis.Pipeliner) error) []redis.Cmder); ok {
		r0 = rf(ctx, fn)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]redis.Cmder)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, func(redis.Pipeliner) error) error); ok {
		r1 = rf(ctx, fn)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PubSubChannels provides a mock function with given fields: ctx, pattern
func (_m *Cmdable) PubSubChannels(ctx context.Context, pattern string) *redis.StringSliceCmd {
	ret := _m.Called(ctx, pattern)

	if len(ret) == 0 {
		panic("no return value specified for PubSubChannels")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, pattern)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// PubSubNumPat provides a mock function with given fields: ctx
func (_m *Cmdable) PubSubNumPat(ctx context.Context) *redis.IntCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for PubSubNumPat")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.IntCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// PubSubNumSub provides a mock function with given fields: ctx, channels
func (_m *Cmdable) PubSubNumSub(ctx context.Context, channels ...string) *redis.StringIntMapCmd {
	_va := make([]interface{}, len(channels))
	for _i := range channels {
		_va[_i] = channels[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PubSubNumSub")
	}

	var r0 *redis.StringIntMapCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.StringIntMapCmd); ok {
		r0 = rf(ctx, channels...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringIntMapCmd)
		}
	}

	return r0
}

// Publish provides a mock function with given fields: ctx, channel, message
func (_m *Cmdable) Publish(ctx context.Context, channel string, message interface{}) *redis.IntCmd {
	ret := _m.Called(ctx, channel, message)

	if len(ret) == 0 {
		panic("no return value specified for Publish")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, channel, message)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// Quit provides a mock function with given fields: ctx
func (_m *Cmdable) Quit(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Quit")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// RPop provides a mock function with given fields: ctx, key
func (_m *Cmdable) RPop(ctx context.Context, key string) *redis.StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for RPop")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// RPopCount provides a mock function with given fields: ctx, key, count
func (_m *Cmdable) RPopCount(ctx context.Context, key string, count int) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, count)

	if len(ret) == 0 {
		panic("no return value specified for RPopCount")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// RPopLPush provides a mock function with given fields: ctx, source, destination
func (_m *Cmdable) RPopLPush(ctx context.Context, source string, destination string) *redis.StringCmd {
	ret := _m.Called(ctx, source, destination)

	if len(ret) == 0 {
		panic("no return value specified for RPopLPush")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.StringCmd); ok {
		r0 = rf(ctx, source, destination)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// RPush provides a mock function with given fields: ctx, key, values
func (_m *Cmdable) RPush(ctx context.Context, key string, values ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RPush")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// RPushX provides a mock function with given fields: ctx, key, values
func (_m *Cmdable) RPushX(ctx context.Context, key string, values ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RPushX")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// RandomKey provides a mock function with given fields: ctx
func (_m *Cmdable) RandomKey(ctx context.Context) *redis.StringCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for RandomKey")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StringCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// ReadOnly provides a mock function with given fields: ctx
func (_m *Cmdable) ReadOnly(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ReadOnly")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ReadWrite provides a mock function with given fields: ctx
func (_m *Cmdable) ReadWrite(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ReadWrite")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// Rename provides a mock function with given fields: ctx, key, newkey
func (_m *Cmdable) Rename(ctx context.Context, key string, newkey string) *redis.StatusCmd {
	ret := _m.Called(ctx, key, newkey)

	if len(ret) == 0 {
		panic("no return value specified for Rename")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, newkey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// RenameNX provides a mock function with given fields: ctx, key, newkey
func (_m *Cmdable) RenameNX(ctx context.Context, key string, newkey string) *redis.BoolCmd {
	ret := _m.Called(ctx, key, newkey)

	if len(ret) == 0 {
		panic("no return value specified for RenameNX")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, newkey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// Restore provides a mock function with given fields: ctx, key, ttl, value
func (_m *Cmdable) Restore(ctx context.Context, key string, ttl time.Duration, value string) *redis.StatusCmd {
	ret := _m.Called(ctx, key, ttl, value)

	if len(ret) == 0 {
		panic("no return value specified for Restore")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, ttl, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// RestoreReplace provides a mock function with given fields: ctx, key, ttl, value
func (_m *Cmdable) RestoreReplace(ctx context.Context, key string, ttl time.Duration, value string) *redis.StatusCmd {
	ret := _m.Called(ctx, key, ttl, value)

	if len(ret) == 0 {
		panic("no return value specified for RestoreReplace")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, ttl, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// SAdd provides a mock function with given fields: ctx, key, members
func (_m *Cmdable) SAdd(ctx context.Context, key string, members ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, members...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SAdd")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// SCard provides a mock function with given fields: ctx, key
func (_m *Cmdable) SCard(ctx context.Context, key string) *redis.IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for SCard")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// SDiff provides a mock function with given fields: ctx, keys
func (_m *Cmdable) SDiff(ctx context.Context, keys ...string) *redis.StringSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SDiff")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// SDiffStore provides a mock function with given fields: ctx, destination, keys
func (_m *Cmdable) SDiffStore(ctx context.Context, destination string, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, destination)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SDiffStore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, destination, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// SInter provides a mock function with given fields: ctx, keys
func (_m *Cmdable) SInter(ctx context.Context, keys ...string) *redis.StringSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SInter")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// SInterStore provides a mock function with given fields: ctx, destination, keys
func (_m *Cmdable) SInterStore(ctx context.Context, destination string, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, destination)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SInterStore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, destination, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// SIsMember provides a mock function with given fields: ctx, key, member
func (_m *Cmdable) SIsMember(ctx context.Context, key string, member interface{}) *redis.BoolCmd {
	ret := _m.Called(ctx, key, member)

	if len(ret) == 0 {
		panic("no return value specified for SIsMember")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// SMIsMember provides a mock function with given fields: ctx, key, members
func (_m *Cmdable) SMIsMember(ctx context.Context, key string, members ...interface{}) *redis.BoolSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, members...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SMIsMember")
	}

	var r0 *redis.BoolSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.BoolSliceCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolSliceCmd)
		}
	}

	return r0
}

// SMembers provides a mock function with given fields: ctx, key
func (_m *Cmdable) SMembers(ctx context.Context, key string) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for SMembers")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// SMembersMap provides a mock function with given fields: ctx, key
func (_m *Cmdable) SMembersMap(ctx context.Context, key string) *redis.StringStructMapCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for SMembersMap")
	}

	var r0 *redis.StringStructMapCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringStructMapCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringStructMapCmd)
		}
	}

	return r0
}

// SMove provides a mock function with given fields: ctx, source, destination, member
func (_m *Cmdable) SMove(ctx context.Context, source string, destination string, member interface{}) *redis.BoolCmd {
	ret := _m.Called(ctx, source, destination, member)

	if len(ret) == 0 {
		panic("no return value specified for SMove")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, interface{}) *redis.BoolCmd); ok {
		r0 = rf(ctx, source, destination, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// SPop provides a mock function with given fields: ctx, key
func (_m *Cmdable) SPop(ctx context.Context, key string) *redis.StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for SPop")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// SPopN provides a mock function with given fields: ctx, key, count
func (_m *Cmdable) SPopN(ctx context.Context, key string, count int64) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, count)

	if len(ret) == 0 {
		panic("no return value specified for SPopN")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// SRandMember provides a mock function with given fields: ctx, key
func (_m *Cmdable) SRandMember(ctx context.Context, key string) *redis.StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for SRandMember")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// SRandMemberN provides a mock function with given fields: ctx, key, count
func (_m *Cmdable) SRandMemberN(ctx context.Context, key string, count int64) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, count)

	if len(ret) == 0 {
		panic("no return value specified for SRandMemberN")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// SRem provides a mock function with given fields: ctx, key, members
func (_m *Cmdable) SRem(ctx context.Context, key string, members ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, members...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SRem")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// SScan provides a mock function with given fields: ctx, key, cursor, match, count
func (_m *Cmdable) SScan(ctx context.Context, key string, cursor uint64, match string, count int64) *redis.ScanCmd {
	ret := _m.Called(ctx, key, cursor, match, count)

	if len(ret) == 0 {
		panic("no return value specified for SScan")
	}

	var r0 *redis.ScanCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, uint64, string, int64) *redis.ScanCmd); ok {
		r0 = rf(ctx, key, cursor, match, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ScanCmd)
		}
	}

	return r0
}

// SUnion provides a mock function with given fields: ctx, keys
func (_m *Cmdable) SUnion(ctx context.Context, keys ...string) *redis.StringSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SUnion")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// SUnionStore provides a mock function with given fields: ctx, destination, keys
func (_m *Cmdable) SUnionStore(ctx context.Context, destination string, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, destination)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SUnionStore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, destination, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// Save provides a mock function with given fields: ctx
func (_m *Cmdable) Save(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Save")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// Scan provides a mock function with given fields: ctx, cursor, match, count
func (_m *Cmdable) Scan(ctx context.Context, cursor uint64, match string, count int64) *redis.ScanCmd {
	ret := _m.Called(ctx, cursor, match, count)

	if len(ret) == 0 {
		panic("no return value specified for Scan")
	}

	var r0 *redis.ScanCmd
	if rf, ok := ret.Get(0).(func(context.Context, uint64, string, int64) *redis.ScanCmd); ok {
		r0 = rf(ctx, cursor, match, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ScanCmd)
		}
	}

	return r0
}

// ScanType provides a mock function with given fields: ctx, cursor, match, count, keyType
func (_m *Cmdable) ScanType(ctx context.Context, cursor uint64, match string, count int64, keyType string) *redis.ScanCmd {
	ret := _m.Called(ctx, cursor, match, count, keyType)

	if len(ret) == 0 {
		panic("no return value specified for ScanType")
	}

	var r0 *redis.ScanCmd
	if rf, ok := ret.Get(0).(func(context.Context, uint64, string, int64, string) *redis.ScanCmd); ok {
		r0 = rf(ctx, cursor, match, count, keyType)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ScanCmd)
		}
	}

	return r0
}

// ScriptExists provides a mock function with given fields: ctx, hashes
func (_m *Cmdable) ScriptExists(ctx context.Context, hashes ...string) *redis.BoolSliceCmd {
	_va := make([]interface{}, len(hashes))
	for _i := range hashes {
		_va[_i] = hashes[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ScriptExists")
	}

	var r0 *redis.BoolSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.BoolSliceCmd); ok {
		r0 = rf(ctx, hashes...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolSliceCmd)
		}
	}

	return r0
}

// ScriptFlush provides a mock function with given fields: ctx
func (_m *Cmdable) ScriptFlush(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ScriptFlush")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ScriptKill provides a mock function with given fields: ctx
func (_m *Cmdable) ScriptKill(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ScriptKill")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ScriptLoad provides a mock function with given fields: ctx, script
func (_m *Cmdable) ScriptLoad(ctx context.Context, script string) *redis.StringCmd {
	ret := _m.Called(ctx, script)

	if len(ret) == 0 {
		panic("no return value specified for ScriptLoad")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringCmd); ok {
		r0 = rf(ctx, script)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// Set provides a mock function with given fields: ctx, key, value, expiration
func (_m *Cmdable) Set(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.StatusCmd {
	ret := _m.Called(ctx, key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for Set")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, time.Duration) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, value, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// SetArgs provides a mock function with given fields: ctx, key, value, a
func (_m *Cmdable) SetArgs(ctx context.Context, key string, value interface{}, a redis.SetArgs) *redis.StatusCmd {
	ret := _m.Called(ctx, key, value, a)

	if len(ret) == 0 {
		panic("no return value specified for SetArgs")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, redis.SetArgs) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, value, a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// SetBit provides a mock function with given fields: ctx, key, offset, value
func (_m *Cmdable) SetBit(ctx context.Context, key string, offset int64, value int) *redis.IntCmd {
	ret := _m.Called(ctx, key, offset, value)

	if len(ret) == 0 {
		panic("no return value specified for SetBit")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int) *redis.IntCmd); ok {
		r0 = rf(ctx, key, offset, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// SetEX provides a mock function with given fields: ctx, key, value, expiration
func (_m *Cmdable) SetEX(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.StatusCmd {
	ret := _m.Called(ctx, key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for SetEX")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, time.Duration) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, value, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// SetNX provides a mock function with given fields: ctx, key, value, expiration
func (_m *Cmdable) SetNX(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.BoolCmd {
	ret := _m.Called(ctx, key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for SetNX")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, time.Duration) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, value, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// SetRange provides a mock function with given fields: ctx, key, offset, value
func (_m *Cmdable) SetRange(ctx context.Context, key string, offset int64, value string) *redis.IntCmd {
	ret := _m.Called(ctx, key, offset, value)

	if len(ret) == 0 {
		panic("no return value specified for SetRange")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key, offset, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// SetXX provides a mock function with given fields: ctx, key, value, expiration
func (_m *Cmdable) SetXX(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.BoolCmd {
	ret := _m.Called(ctx, key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for SetXX")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, time.Duration) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, value, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// Shutdown provides a mock function with given fields: ctx
func (_m *Cmdable) Shutdown(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Shutdown")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ShutdownNoSave provides a mock function with given fields: ctx
func (_m *Cmdable) ShutdownNoSave(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ShutdownNoSave")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ShutdownSave provides a mock function with given fields: ctx
func (_m *Cmdable) ShutdownSave(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ShutdownSave")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// SlaveOf provides a mock function with given fields: ctx, host, port
func (_m *Cmdable) SlaveOf(ctx context.Context, host string, port string) *redis.StatusCmd {
	ret := _m.Called(ctx, host, port)

	if len(ret) == 0 {
		panic("no return value specified for SlaveOf")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, host, port)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// Sort provides a mock function with given fields: ctx, key, sort
func (_m *Cmdable) Sort(ctx context.Context, key string, sort *redis.Sort) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, sort)

	if len(ret) == 0 {
		panic("no return value specified for Sort")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.Sort) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, sort)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// SortInterfaces provides a mock function with given fields: ctx, key, sort
func (_m *Cmdable) SortInterfaces(ctx context.Context, key string, sort *redis.Sort) *redis.SliceCmd {
	ret := _m.Called(ctx, key, sort)

	if len(ret) == 0 {
		panic("no return value specified for SortInterfaces")
	}

	var r0 *redis.SliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.Sort) *redis.SliceCmd); ok {
		r0 = rf(ctx, key, sort)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.SliceCmd)
		}
	}

	return r0
}

// SortStore provides a mock function with given fields: ctx, key, store, sort
func (_m *Cmdable) SortStore(ctx context.Context, key string, store string, sort *redis.Sort) *redis.IntCmd {
	ret := _m.Called(ctx, key, store, sort)

	if len(ret) == 0 {
		panic("no return value specified for SortStore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *redis.Sort) *redis.IntCmd); ok {
		r0 = rf(ctx, key, store, sort)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// StrLen provides a mock function with given fields: ctx, key
func (_m *Cmdable) StrLen(ctx context.Context, key string) *redis.IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for StrLen")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// TTL provides a mock function with given fields: ctx, key
func (_m *Cmdable) TTL(ctx context.Context, key string) *redis.DurationCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for TTL")
	}

	var r0 *redis.DurationCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.DurationCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.DurationCmd)
		}
	}

	return r0
}

// Time provides a mock function with given fields: ctx
func (_m *Cmdable) Time(ctx context.Context) *redis.TimeCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Time")
	}

	var r0 *redis.TimeCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.TimeCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.TimeCmd)
		}
	}

	return r0
}

// Touch provides a mock function with given fields: ctx, keys
func (_m *Cmdable) Touch(ctx context.Context, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Touch")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// TxPipeline provides a mock function with no fields
func (_m *Cmdable) TxPipeline() redis.Pipeliner {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for TxPipeline")
	}

	var r0 redis.Pipeliner
	if rf, ok := ret.Get(0).(func() redis.Pipeliner); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(redis.Pipeliner)
		}
	}

	return r0
}

// TxPipelined provides a mock function with given fields: ctx, fn
func (_m *Cmdable) TxPipelined(ctx context.Context, fn func(redis.Pipeliner) error) ([]redis.Cmder, error) {
	ret := _m.Called(ctx, fn)

	if len(ret) == 0 {
		panic("no return value specified for TxPipelined")
	}

	var r0 []redis.Cmder
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, func(redis.Pipeliner) error) ([]redis.Cmder, error)); ok {
		return rf(ctx, fn)
	}
	if rf, ok := ret.Get(0).(func(context.Context, func(redis.Pipeliner) error) []redis.Cmder); ok {
		r0 = rf(ctx, fn)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]redis.Cmder)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, func(redis.Pipeliner) error) error); ok {
		r1 = rf(ctx, fn)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Type provides a mock function with given fields: ctx, key
func (_m *Cmdable) Type(ctx context.Context, key string) *redis.StatusCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for Type")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// Unlink provides a mock function with given fields: ctx, keys
func (_m *Cmdable) Unlink(ctx context.Context, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Unlink")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// XAck provides a mock function with given fields: ctx, stream, group, ids
func (_m *Cmdable) XAck(ctx context.Context, stream string, group string, ids ...string) *redis.IntCmd {
	_va := make([]interface{}, len(ids))
	for _i := range ids {
		_va[_i] = ids[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stream, group)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for XAck")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, stream, group, ids...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// XAdd provides a mock function with given fields: ctx, a
func (_m *Cmdable) XAdd(ctx context.Context, a *redis.XAddArgs) *redis.StringCmd {
	ret := _m.Called(ctx, a)

	if len(ret) == 0 {
		panic("no return value specified for XAdd")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, *redis.XAddArgs) *redis.StringCmd); ok {
		r0 = rf(ctx, a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// XAutoClaim provides a mock function with given fields: ctx, a
func (_m *Cmdable) XAutoClaim(ctx context.Context, a *redis.XAutoClaimArgs) *redis.XAutoClaimCmd {
	ret := _m.Called(ctx, a)

	if len(ret) == 0 {
		panic("no return value specified for XAutoClaim")
	}

	var r0 *redis.XAutoClaimCmd
	if rf, ok := ret.Get(0).(func(context.Context, *redis.XAutoClaimArgs) *redis.XAutoClaimCmd); ok {
		r0 = rf(ctx, a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XAutoClaimCmd)
		}
	}

	return r0
}

// XAutoClaimJustID provides a mock function with given fields: ctx, a
func (_m *Cmdable) XAutoClaimJustID(ctx context.Context, a *redis.XAutoClaimArgs) *redis.XAutoClaimJustIDCmd {
	ret := _m.Called(ctx, a)

	if len(ret) == 0 {
		panic("no return value specified for XAutoClaimJustID")
	}

	var r0 *redis.XAutoClaimJustIDCmd
	if rf, ok := ret.Get(0).(func(context.Context, *redis.XAutoClaimArgs) *redis.XAutoClaimJustIDCmd); ok {
		r0 = rf(ctx, a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XAutoClaimJustIDCmd)
		}
	}

	return r0
}

// XClaim provides a mock function with given fields: ctx, a
func (_m *Cmdable) XClaim(ctx context.Context, a *redis.XClaimArgs) *redis.XMessageSliceCmd {
	ret := _m.Called(ctx, a)

	if len(ret) == 0 {
		panic("no return value specified for XClaim")
	}

	var r0 *redis.XMessageSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, *redis.XClaimArgs) *redis.XMessageSliceCmd); ok {
		r0 = rf(ctx, a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XMessageSliceCmd)
		}
	}

	return r0
}

// XClaimJustID provides a mock function with given fields: ctx, a
func (_m *Cmdable) XClaimJustID(ctx context.Context, a *redis.XClaimArgs) *redis.StringSliceCmd {
	ret := _m.Called(ctx, a)

	if len(ret) == 0 {
		panic("no return value specified for XClaimJustID")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, *redis.XClaimArgs) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// XDel provides a mock function with given fields: ctx, stream, ids
func (_m *Cmdable) XDel(ctx context.Context, stream string, ids ...string) *redis.IntCmd {
	_va := make([]interface{}, len(ids))
	for _i := range ids {
		_va[_i] = ids[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stream)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for XDel")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, stream, ids...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// XGroupCreate provides a mock function with given fields: ctx, stream, group, start
func (_m *Cmdable) XGroupCreate(ctx context.Context, stream string, group string, start string) *redis.StatusCmd {
	ret := _m.Called(ctx, stream, group, start)

	if len(ret) == 0 {
		panic("no return value specified for XGroupCreate")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, stream, group, start)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// XGroupCreateConsumer provides a mock function with given fields: ctx, stream, group, consumer
func (_m *Cmdable) XGroupCreateConsumer(ctx context.Context, stream string, group string, consumer string) *redis.IntCmd {
	ret := _m.Called(ctx, stream, group, consumer)

	if len(ret) == 0 {
		panic("no return value specified for XGroupCreateConsumer")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, stream, group, consumer)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// XGroupCreateMkStream provides a mock function with given fields: ctx, stream, group, start
func (_m *Cmdable) XGroupCreateMkStream(ctx context.Context, stream string, group string, start string) *redis.StatusCmd {
	ret := _m.Called(ctx, stream, group, start)

	if len(ret) == 0 {
		panic("no return value specified for XGroupCreateMkStream")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, stream, group, start)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// XGroupDelConsumer provides a mock function with given fields: ctx, stream, group, consumer
func (_m *Cmdable) XGroupDelConsumer(ctx context.Context, stream string, group string, consumer string) *redis.IntCmd {
	ret := _m.Called(ctx, stream, group, consumer)

	if len(ret) == 0 {
		panic("no return value specified for XGroupDelConsumer")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, stream, group, consumer)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// XGroupDestroy provides a mock function with given fields: ctx, stream, group
func (_m *Cmdable) XGroupDestroy(ctx context.Context, stream string, group string) *redis.IntCmd {
	ret := _m.Called(ctx, stream, group)

	if len(ret) == 0 {
		panic("no return value specified for XGroupDestroy")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, stream, group)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// XGroupSetID provides a mock function with given fields: ctx, stream, group, start
func (_m *Cmdable) XGroupSetID(ctx context.Context, stream string, group string, start string) *redis.StatusCmd {
	ret := _m.Called(ctx, stream, group, start)

	if len(ret) == 0 {
		panic("no return value specified for XGroupSetID")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, stream, group, start)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// XInfoConsumers provides a mock function with given fields: ctx, key, group
func (_m *Cmdable) XInfoConsumers(ctx context.Context, key string, group string) *redis.XInfoConsumersCmd {
	ret := _m.Called(ctx, key, group)

	if len(ret) == 0 {
		panic("no return value specified for XInfoConsumers")
	}

	var r0 *redis.XInfoConsumersCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.XInfoConsumersCmd); ok {
		r0 = rf(ctx, key, group)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XInfoConsumersCmd)
		}
	}

	return r0
}

// XInfoGroups provides a mock function with given fields: ctx, key
func (_m *Cmdable) XInfoGroups(ctx context.Context, key string) *redis.XInfoGroupsCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for XInfoGroups")
	}

	var r0 *redis.XInfoGroupsCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.XInfoGroupsCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XInfoGroupsCmd)
		}
	}

	return r0
}

// XInfoStream provides a mock function with given fields: ctx, key
func (_m *Cmdable) XInfoStream(ctx context.Context, key string) *redis.XInfoStreamCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for XInfoStream")
	}

	var r0 *redis.XInfoStreamCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.XInfoStreamCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XInfoStreamCmd)
		}
	}

	return r0
}

// XInfoStreamFull provides a mock function with given fields: ctx, key, count
func (_m *Cmdable) XInfoStreamFull(ctx context.Context, key string, count int) *redis.XInfoStreamFullCmd {
	ret := _m.Called(ctx, key, count)

	if len(ret) == 0 {
		panic("no return value specified for XInfoStreamFull")
	}

	var r0 *redis.XInfoStreamFullCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int) *redis.XInfoStreamFullCmd); ok {
		r0 = rf(ctx, key, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XInfoStreamFullCmd)
		}
	}

	return r0
}

// XLen provides a mock function with given fields: ctx, stream
func (_m *Cmdable) XLen(ctx context.Context, stream string) *redis.IntCmd {
	ret := _m.Called(ctx, stream)

	if len(ret) == 0 {
		panic("no return value specified for XLen")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.IntCmd); ok {
		r0 = rf(ctx, stream)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// XPending provides a mock function with given fields: ctx, stream, group
func (_m *Cmdable) XPending(ctx context.Context, stream string, group string) *redis.XPendingCmd {
	ret := _m.Called(ctx, stream, group)

	if len(ret) == 0 {
		panic("no return value specified for XPending")
	}

	var r0 *redis.XPendingCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.XPendingCmd); ok {
		r0 = rf(ctx, stream, group)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XPendingCmd)
		}
	}

	return r0
}

// XPendingExt provides a mock function with given fields: ctx, a
func (_m *Cmdable) XPendingExt(ctx context.Context, a *redis.XPendingExtArgs) *redis.XPendingExtCmd {
	ret := _m.Called(ctx, a)

	if len(ret) == 0 {
		panic("no return value specified for XPendingExt")
	}

	var r0 *redis.XPendingExtCmd
	if rf, ok := ret.Get(0).(func(context.Context, *redis.XPendingExtArgs) *redis.XPendingExtCmd); ok {
		r0 = rf(ctx, a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XPendingExtCmd)
		}
	}

	return r0
}

// XRange provides a mock function with given fields: ctx, stream, start, stop
func (_m *Cmdable) XRange(ctx context.Context, stream string, start string, stop string) *redis.XMessageSliceCmd {
	ret := _m.Called(ctx, stream, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for XRange")
	}

	var r0 *redis.XMessageSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *redis.XMessageSliceCmd); ok {
		r0 = rf(ctx, stream, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XMessageSliceCmd)
		}
	}

	return r0
}

// XRangeN provides a mock function with given fields: ctx, stream, start, stop, count
func (_m *Cmdable) XRangeN(ctx context.Context, stream string, start string, stop string, count int64) *redis.XMessageSliceCmd {
	ret := _m.Called(ctx, stream, start, stop, count)

	if len(ret) == 0 {
		panic("no return value specified for XRangeN")
	}

	var r0 *redis.XMessageSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int64) *redis.XMessageSliceCmd); ok {
		r0 = rf(ctx, stream, start, stop, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XMessageSliceCmd)
		}
	}

	return r0
}

// XRead provides a mock function with given fields: ctx, a
func (_m *Cmdable) XRead(ctx context.Context, a *redis.XReadArgs) *redis.XStreamSliceCmd {
	ret := _m.Called(ctx, a)

	if len(ret) == 0 {
		panic("no return value specified for XRead")
	}

	var r0 *redis.XStreamSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, *redis.XReadArgs) *redis.XStreamSliceCmd); ok {
		r0 = rf(ctx, a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XStreamSliceCmd)
		}
	}

	return r0
}

// XReadGroup provides a mock function with given fields: ctx, a
func (_m *Cmdable) XReadGroup(ctx context.Context, a *redis.XReadGroupArgs) *redis.XStreamSliceCmd {
	ret := _m.Called(ctx, a)

	if len(ret) == 0 {
		panic("no return value specified for XReadGroup")
	}

	var r0 *redis.XStreamSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, *redis.XReadGroupArgs) *redis.XStreamSliceCmd); ok {
		r0 = rf(ctx, a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XStreamSliceCmd)
		}
	}

	return r0
}

// XReadStreams provides a mock function with given fields: ctx, streams
func (_m *Cmdable) XReadStreams(ctx context.Context, streams ...string) *redis.XStreamSliceCmd {
	_va := make([]interface{}, len(streams))
	for _i := range streams {
		_va[_i] = streams[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for XReadStreams")
	}

	var r0 *redis.XStreamSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.XStreamSliceCmd); ok {
		r0 = rf(ctx, streams...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XStreamSliceCmd)
		}
	}

	return r0
}

// XRevRange provides a mock function with given fields: ctx, stream, start, stop
func (_m *Cmdable) XRevRange(ctx context.Context, stream string, start string, stop string) *redis.XMessageSliceCmd {
	ret := _m.Called(ctx, stream, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for XRevRange")
	}

	var r0 *redis.XMessageSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *redis.XMessageSliceCmd); ok {
		r0 = rf(ctx, stream, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XMessageSliceCmd)
		}
	}

	return r0
}

// XRevRangeN provides a mock function with given fields: ctx, stream, start, stop, count
func (_m *Cmdable) XRevRangeN(ctx context.Context, stream string, start string, stop string, count int64) *redis.XMessageSliceCmd {
	ret := _m.Called(ctx, stream, start, stop, count)

	if len(ret) == 0 {
		panic("no return value specified for XRevRangeN")
	}

	var r0 *redis.XMessageSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int64) *redis.XMessageSliceCmd); ok {
		r0 = rf(ctx, stream, start, stop, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XMessageSliceCmd)
		}
	}

	return r0
}

// XTrim provides a mock function with given fields: ctx, key, maxLen
func (_m *Cmdable) XTrim(ctx context.Context, key string, maxLen int64) *redis.IntCmd {
	ret := _m.Called(ctx, key, maxLen)

	if len(ret) == 0 {
		panic("no return value specified for XTrim")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *redis.IntCmd); ok {
		r0 = rf(ctx, key, maxLen)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// XTrimApprox provides a mock function with given fields: ctx, key, maxLen
func (_m *Cmdable) XTrimApprox(ctx context.Context, key string, maxLen int64) *redis.IntCmd {
	ret := _m.Called(ctx, key, maxLen)

	if len(ret) == 0 {
		panic("no return value specified for XTrimApprox")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *redis.IntCmd); ok {
		r0 = rf(ctx, key, maxLen)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// XTrimMaxLen provides a mock function with given fields: ctx, key, maxLen
func (_m *Cmdable) XTrimMaxLen(ctx context.Context, key string, maxLen int64) *redis.IntCmd {
	ret := _m.Called(ctx, key, maxLen)

	if len(ret) == 0 {
		panic("no return value specified for XTrimMaxLen")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *redis.IntCmd); ok {
		r0 = rf(ctx, key, maxLen)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// XTrimMaxLenApprox provides a mock function with given fields: ctx, key, maxLen, limit
func (_m *Cmdable) XTrimMaxLenApprox(ctx context.Context, key string, maxLen int64, limit int64) *redis.IntCmd {
	ret := _m.Called(ctx, key, maxLen, limit)

	if len(ret) == 0 {
		panic("no return value specified for XTrimMaxLenApprox")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *redis.IntCmd); ok {
		r0 = rf(ctx, key, maxLen, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// XTrimMinID provides a mock function with given fields: ctx, key, minID
func (_m *Cmdable) XTrimMinID(ctx context.Context, key string, minID string) *redis.IntCmd {
	ret := _m.Called(ctx, key, minID)

	if len(ret) == 0 {
		panic("no return value specified for XTrimMinID")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key, minID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// XTrimMinIDApprox provides a mock function with given fields: ctx, key, minID, limit
func (_m *Cmdable) XTrimMinIDApprox(ctx context.Context, key string, minID string, limit int64) *redis.IntCmd {
	ret := _m.Called(ctx, key, minID, limit)

	if len(ret) == 0 {
		panic("no return value specified for XTrimMinIDApprox")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int64) *redis.IntCmd); ok {
		r0 = rf(ctx, key, minID, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZAdd provides a mock function with given fields: ctx, key, members
func (_m *Cmdable) ZAdd(ctx context.Context, key string, members ...*redis.Z) *redis.IntCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZAdd")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...*redis.Z) *redis.IntCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZAddArgs provides a mock function with given fields: ctx, key, args
func (_m *Cmdable) ZAddArgs(ctx context.Context, key string, args redis.ZAddArgs) *redis.IntCmd {
	ret := _m.Called(ctx, key, args)

	if len(ret) == 0 {
		panic("no return value specified for ZAddArgs")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, redis.ZAddArgs) *redis.IntCmd); ok {
		r0 = rf(ctx, key, args)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZAddArgsIncr provides a mock function with given fields: ctx, key, args
func (_m *Cmdable) ZAddArgsIncr(ctx context.Context, key string, args redis.ZAddArgs) *redis.FloatCmd {
	ret := _m.Called(ctx, key, args)

	if len(ret) == 0 {
		panic("no return value specified for ZAddArgsIncr")
	}

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, redis.ZAddArgs) *redis.FloatCmd); ok {
		r0 = rf(ctx, key, args)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// ZAddCh provides a mock function with given fields: ctx, key, members
func (_m *Cmdable) ZAddCh(ctx context.Context, key string, members ...*redis.Z) *redis.IntCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZAddCh")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...*redis.Z) *redis.IntCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZAddNX provides a mock function with given fields: ctx, key, members
func (_m *Cmdable) ZAddNX(ctx context.Context, key string, members ...*redis.Z) *redis.IntCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZAddNX")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...*redis.Z) *redis.IntCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZAddNXCh provides a mock function with given fields: ctx, key, members
func (_m *Cmdable) ZAddNXCh(ctx context.Context, key string, members ...*redis.Z) *redis.IntCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZAddNXCh")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...*redis.Z) *redis.IntCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZAddXX provides a mock function with given fields: ctx, key, members
func (_m *Cmdable) ZAddXX(ctx context.Context, key string, members ...*redis.Z) *redis.IntCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZAddXX")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...*redis.Z) *redis.IntCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZAddXXCh provides a mock function with given fields: ctx, key, members
func (_m *Cmdable) ZAddXXCh(ctx context.Context, key string, members ...*redis.Z) *redis.IntCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZAddXXCh")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...*redis.Z) *redis.IntCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZCard provides a mock function with given fields: ctx, key
func (_m *Cmdable) ZCard(ctx context.Context, key string) *redis.IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for ZCard")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZCount provides a mock function with given fields: ctx, key, min, max
func (_m *Cmdable) ZCount(ctx context.Context, key string, min string, max string) *redis.IntCmd {
	ret := _m.Called(ctx, key, min, max)

	if len(ret) == 0 {
		panic("no return value specified for ZCount")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key, min, max)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZDiff provides a mock function with given fields: ctx, keys
func (_m *Cmdable) ZDiff(ctx context.Context, keys ...string) *redis.StringSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZDiff")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ZDiffStore provides a mock function with given fields: ctx, destination, keys
func (_m *Cmdable) ZDiffStore(ctx context.Context, destination string, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, destination)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZDiffStore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, destination, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZDiffWithScores provides a mock function with given fields: ctx, keys
func (_m *Cmdable) ZDiffWithScores(ctx context.Context, keys ...string) *redis.ZSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZDiffWithScores")
	}

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.ZSliceCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// ZIncr provides a mock function with given fields: ctx, key, member
func (_m *Cmdable) ZIncr(ctx context.Context, key string, member *redis.Z) *redis.FloatCmd {
	ret := _m.Called(ctx, key, member)

	if len(ret) == 0 {
		panic("no return value specified for ZIncr")
	}

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.Z) *redis.FloatCmd); ok {
		r0 = rf(ctx, key, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// ZIncrBy provides a mock function with given fields: ctx, key, increment, member
func (_m *Cmdable) ZIncrBy(ctx context.Context, key string, increment float64, member string) *redis.FloatCmd {
	ret := _m.Called(ctx, key, increment, member)

	if len(ret) == 0 {
		panic("no return value specified for ZIncrBy")
	}

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, float64, string) *redis.FloatCmd); ok {
		r0 = rf(ctx, key, increment, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// ZIncrNX provides a mock function with given fields: ctx, key, member
func (_m *Cmdable) ZIncrNX(ctx context.Context, key string, member *redis.Z) *redis.FloatCmd {
	ret := _m.Called(ctx, key, member)

	if len(ret) == 0 {
		panic("no return value specified for ZIncrNX")
	}

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.Z) *redis.FloatCmd); ok {
		r0 = rf(ctx, key, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// ZIncrXX provides a mock function with given fields: ctx, key, member
func (_m *Cmdable) ZIncrXX(ctx context.Context, key string, member *redis.Z) *redis.FloatCmd {
	ret := _m.Called(ctx, key, member)

	if len(ret) == 0 {
		panic("no return value specified for ZIncrXX")
	}

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.Z) *redis.FloatCmd); ok {
		r0 = rf(ctx, key, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// ZInter provides a mock function with given fields: ctx, store
func (_m *Cmdable) ZInter(ctx context.Context, store *redis.ZStore) *redis.StringSliceCmd {
	ret := _m.Called(ctx, store)

	if len(ret) == 0 {
		panic("no return value specified for ZInter")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, *redis.ZStore) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, store)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ZInterStore provides a mock function with given fields: ctx, destination, store
func (_m *Cmdable) ZInterStore(ctx context.Context, destination string, store *redis.ZStore) *redis.IntCmd {
	ret := _m.Called(ctx, destination, store)

	if len(ret) == 0 {
		panic("no return value specified for ZInterStore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.ZStore) *redis.IntCmd); ok {
		r0 = rf(ctx, destination, store)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZInterWithScores provides a mock function with given fields: ctx, store
func (_m *Cmdable) ZInterWithScores(ctx context.Context, store *redis.ZStore) *redis.ZSliceCmd {
	ret := _m.Called(ctx, store)

	if len(ret) == 0 {
		panic("no return value specified for ZInterWithScores")
	}

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, *redis.ZStore) *redis.ZSliceCmd); ok {
		r0 = rf(ctx, store)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// ZLexCount provides a mock function with given fields: ctx, key, min, max
func (_m *Cmdable) ZLexCount(ctx context.Context, key string, min string, max string) *redis.IntCmd {
	ret := _m.Called(ctx, key, min, max)

	if len(ret) == 0 {
		panic("no return value specified for ZLexCount")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key, min, max)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZMScore provides a mock function with given fields: ctx, key, members
func (_m *Cmdable) ZMScore(ctx context.Context, key string, members ...string) *redis.FloatSliceCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZMScore")
	}

	var r0 *redis.FloatSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.FloatSliceCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatSliceCmd)
		}
	}

	return r0
}

// ZPopMax provides a mock function with given fields: ctx, key, count
func (_m *Cmdable) ZPopMax(ctx context.Context, key string, count ...int64) *redis.ZSliceCmd {
	_va := make([]interface{}, len(count))
	for _i := range count {
		_va[_i] = count[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZPopMax")
	}

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...int64) *redis.ZSliceCmd); ok {
		r0 = rf(ctx, key, count...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// ZPopMin provides a mock function with given fields: ctx, key, count
func (_m *Cmdable) ZPopMin(ctx context.Context, key string, count ...int64) *redis.ZSliceCmd {
	_va := make([]interface{}, len(count))
	for _i := range count {
		_va[_i] = count[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZPopMin")
	}

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...int64) *redis.ZSliceCmd); ok {
		r0 = rf(ctx, key, count...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// ZRandMember provides a mock function with given fields: ctx, key, count, withScores
func (_m *Cmdable) ZRandMember(ctx context.Context, key string, count int, withScores bool) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, count, withScores)

	if len(ret) == 0 {
		panic("no return value specified for ZRandMember")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int, bool) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, count, withScores)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ZRange provides a mock function with given fields: ctx, key, start, stop
func (_m *Cmdable) ZRange(ctx context.Context, key string, start int64, stop int64) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for ZRange")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ZRangeArgs provides a mock function with given fields: ctx, z
func (_m *Cmdable) ZRangeArgs(ctx context.Context, z redis.ZRangeArgs) *redis.StringSliceCmd {
	ret := _m.Called(ctx, z)

	if len(ret) == 0 {
		panic("no return value specified for ZRangeArgs")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, redis.ZRangeArgs) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, z)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ZRangeArgsWithScores provides a mock function with given fields: ctx, z
func (_m *Cmdable) ZRangeArgsWithScores(ctx context.Context, z redis.ZRangeArgs) *redis.ZSliceCmd {
	ret := _m.Called(ctx, z)

	if len(ret) == 0 {
		panic("no return value specified for ZRangeArgsWithScores")
	}

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, redis.ZRangeArgs) *redis.ZSliceCmd); ok {
		r0 = rf(ctx, z)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// ZRangeByLex provides a mock function with given fields: ctx, key, opt
func (_m *Cmdable) ZRangeByLex(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, opt)

	if len(ret) == 0 {
		panic("no return value specified for ZRangeByLex")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.ZRangeBy) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ZRangeByScore provides a mock function with given fields: ctx, key, opt
func (_m *Cmdable) ZRangeByScore(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, opt)

	if len(ret) == 0 {
		panic("no return value specified for ZRangeByScore")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.ZRangeBy) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ZRangeByScoreWithScores provides a mock function with given fields: ctx, key, opt
func (_m *Cmdable) ZRangeByScoreWithScores(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.ZSliceCmd {
	ret := _m.Called(ctx, key, opt)

	if len(ret) == 0 {
		panic("no return value specified for ZRangeByScoreWithScores")
	}

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.ZRangeBy) *redis.ZSliceCmd); ok {
		r0 = rf(ctx, key, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// ZRangeStore provides a mock function with given fields: ctx, dst, z
func (_m *Cmdable) ZRangeStore(ctx context.Context, dst string, z redis.ZRangeArgs) *redis.IntCmd {
	ret := _m.Called(ctx, dst, z)

	if len(ret) == 0 {
		panic("no return value specified for ZRangeStore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, redis.ZRangeArgs) *redis.IntCmd); ok {
		r0 = rf(ctx, dst, z)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZRangeWithScores provides a mock function with given fields: ctx, key, start, stop
func (_m *Cmdable) ZRangeWithScores(ctx context.Context, key string, start int64, stop int64) *redis.ZSliceCmd {
	ret := _m.Called(ctx, key, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for ZRangeWithScores")
	}

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *redis.ZSliceCmd); ok {
		r0 = rf(ctx, key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// ZRank provides a mock function with given fields: ctx, key, member
func (_m *Cmdable) ZRank(ctx context.Context, key string, member string) *redis.IntCmd {
	ret := _m.Called(ctx, key, member)

	if len(ret) == 0 {
		panic("no return value specified for ZRank")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZRem provides a mock function with given fields: ctx, key, members
func (_m *Cmdable) ZRem(ctx context.Context, key string, members ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, members...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZRem")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZRemRangeByLex provides a mock function with given fields: ctx, key, min, max
func (_m *Cmdable) ZRemRangeByLex(ctx context.Context, key string, min string, max string) *redis.IntCmd {
	ret := _m.Called(ctx, key, min, max)

	if len(ret) == 0 {
		panic("no return value specified for ZRemRangeByLex")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key, min, max)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZRemRangeByRank provides a mock function with given fields: ctx, key, start, stop
func (_m *Cmdable) ZRemRangeByRank(ctx context.Context, key string, start int64, stop int64) *redis.IntCmd {
	ret := _m.Called(ctx, key, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for ZRemRangeByRank")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *redis.IntCmd); ok {
		r0 = rf(ctx, key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZRemRangeByScore provides a mock function with given fields: ctx, key, min, max
func (_m *Cmdable) ZRemRangeByScore(ctx context.Context, key string, min string, max string) *redis.IntCmd {
	ret := _m.Called(ctx, key, min, max)

	if len(ret) == 0 {
		panic("no return value specified for ZRemRangeByScore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key, min, max)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZRevRange provides a mock function with given fields: ctx, key, start, stop
func (_m *Cmdable) ZRevRange(ctx context.Context, key string, start int64, stop int64) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for ZRevRange")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ZRevRangeByLex provides a mock function with given fields: ctx, key, opt
func (_m *Cmdable) ZRevRangeByLex(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, opt)

	if len(ret) == 0 {
		panic("no return value specified for ZRevRangeByLex")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.ZRangeBy) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ZRevRangeByScore provides a mock function with given fields: ctx, key, opt
func (_m *Cmdable) ZRevRangeByScore(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, opt)

	if len(ret) == 0 {
		panic("no return value specified for ZRevRangeByScore")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.ZRangeBy) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ZRevRangeByScoreWithScores provides a mock function with given fields: ctx, key, opt
func (_m *Cmdable) ZRevRangeByScoreWithScores(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.ZSliceCmd {
	ret := _m.Called(ctx, key, opt)

	if len(ret) == 0 {
		panic("no return value specified for ZRevRangeByScoreWithScores")
	}

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.ZRangeBy) *redis.ZSliceCmd); ok {
		r0 = rf(ctx, key, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// ZRevRangeWithScores provides a mock function with given fields: ctx, key, start, stop
func (_m *Cmdable) ZRevRangeWithScores(ctx context.Context, key string, start int64, stop int64) *redis.ZSliceCmd {
	ret := _m.Called(ctx, key, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for ZRevRangeWithScores")
	}

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *redis.ZSliceCmd); ok {
		r0 = rf(ctx, key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// ZRevRank provides a mock function with given fields: ctx, key, member
func (_m *Cmdable) ZRevRank(ctx context.Context, key string, member string) *redis.IntCmd {
	ret := _m.Called(ctx, key, member)

	if len(ret) == 0 {
		panic("no return value specified for ZRevRank")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZScan provides a mock function with given fields: ctx, key, cursor, match, count
func (_m *Cmdable) ZScan(ctx context.Context, key string, cursor uint64, match string, count int64) *redis.ScanCmd {
	ret := _m.Called(ctx, key, cursor, match, count)

	if len(ret) == 0 {
		panic("no return value specified for ZScan")
	}

	var r0 *redis.ScanCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, uint64, string, int64) *redis.ScanCmd); ok {
		r0 = rf(ctx, key, cursor, match, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ScanCmd)
		}
	}

	return r0
}

// ZScore provides a mock function with given fields: ctx, key, member
func (_m *Cmdable) ZScore(ctx context.Context, key string, member string) *redis.FloatCmd {
	ret := _m.Called(ctx, key, member)

	if len(ret) == 0 {
		panic("no return value specified for ZScore")
	}

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.FloatCmd); ok {
		r0 = rf(ctx, key, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// ZUnion provides a mock function with given fields: ctx, store
func (_m *Cmdable) ZUnion(ctx context.Context, store redis.ZStore) *redis.StringSliceCmd {
	ret := _m.Called(ctx, store)

	if len(ret) == 0 {
		panic("no return value specified for ZUnion")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, redis.ZStore) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, store)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ZUnionStore provides a mock function with given fields: ctx, dest, store
func (_m *Cmdable) ZUnionStore(ctx context.Context, dest string, store *redis.ZStore) *redis.IntCmd {
	ret := _m.Called(ctx, dest, store)

	if len(ret) == 0 {
		panic("no return value specified for ZUnionStore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.ZStore) *redis.IntCmd); ok {
		r0 = rf(ctx, dest, store)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZUnionWithScores provides a mock function with given fields: ctx, store
func (_m *Cmdable) ZUnionWithScores(ctx context.Context, store redis.ZStore) *redis.ZSliceCmd {
	ret := _m.Called(ctx, store)

	if len(ret) == 0 {
		panic("no return value specified for ZUnionWithScores")
	}

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, redis.ZStore) *redis.ZSliceCmd); ok {
		r0 = rf(ctx, store)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// NewCmdable creates a new instance of Cmdable. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCmdable(t interface {
	mock.TestingT
	Cleanup(func())
}) *Cmdable {
	mock := &Cmdable{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
